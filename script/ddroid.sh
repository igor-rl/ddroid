#!/bin/bash

DDROID_VERSION="1.0.18"
CURSOR=">"
RUN_MIGRATION=false
RUN_DATABASE=false

if [ "$1" == "--version" ]; then
  echo "$DDROID_VERSION"
  exit 0
fi

# Analise os argumentos
for arg in "$@"; do
    case $arg in
        --migration=true)
            RUN_MIGRATION=true
            ;;
        --database=true)
            RUN_DATABASE=true
            ;;
    esac
done

unsetVars(){
  CURSOR_POSITION=0
  AMBIENTE=none
  TESTE=none
  LOCAL_OPTIONS=none
  DOCKER_OPTIONS=none
  KBS_OPTIONS=none
}

load_or_create_env() {
  if [ ! -f ddroid.env ]; then
    # Se ddroid.env n√£o existe, cria e preenche com valores padr√£o
    echo "# Docker" > ddroid.env
    echo "DOCKER_HUB_USER=" >> ddroid.env
    echo "DOCKER_HUB_IMAGE=" >> ddroid.env
    echo "DB_CONTAINER_NAME=none" > ddroid.env
    echo "DB_VOLUME=./db/mysql" >> ddroid.env
    echo "BACK_CONTAINER_NAME=none" >> ddroid.env
    echo "" > ddroid.env
    echo "# k8s" > ddroid.env
    echo "K8S_DB_PORTS=(80 80)" >> ddroid.env
    echo "K8S_APP_PORTS=(80 80)" >> ddroid.env
    echo "" > ddroid.env
    echo "K8S_DB_FOLDER=" >> ddroid.env
    echo "K8S_DB_POD_NAME=" >> ddroid.env
    echo "K8S_DB_SERVICE_NAME=" >> ddroid.env
    echo "K8S_API_FOLDER=" >> ddroid.env
    echo "K8S_API_POD_NAME=" >> ddroid.env
    echo "K8S_API_SERVICE_NAME=" >> ddroid.env
  fi
  # Carrega as vari√°veis do arquivo ddroid.env
  source ddroid.env
}

# Analise os argumentos
for arg in "$@"; do
    case $arg in
        --migration=true)
            RUN_MIGRATION=true
            ;;
        --ambiente=docker)
            AMBIENTE=docker
            ;;
        --ambiente=k8s)
            AMBIENTE=k8s
            ;;
        --teste=prod)
            TESTE=prod
            ;;
    esac
done

defineAmbiente(){
  options=("üè†  Local" "üê≥  Docker" "‚öì  Kubernetes" "‚ö∞Ô∏è   Desinstalar DDroid" "üö™  Sair")
  print_menu() {
    for i in "${!options[@]}"; do
      if [[ "$i" -eq $CURSOR_POSITION ]]; then
        echo -e "${CURSOR} ${options[$i]}"
      else
        echo -e "  ${options[$i]}"
      fi
    done
  }
  while true; do
    clear
    echo "ü§ñ DDroid ${CURRENT_VERSION}"
    echo
    echo "Como deseja implantar sua aplica√ß√£o?"
    print_menu
    read -rsn3 key
    if [[ $key == $'\x1b[A' ]]; then
      if [[ "$CURSOR_POSITION" -gt 0 ]]; then
        CURSOR_POSITION=$((CURSOR_POSITION-1))
      fi
    elif [[ $key == $'\x1b[B' ]]; then
      if [[ "$CURSOR_POSITION" -lt $((${#options[@]}-1)) ]]; then
        CURSOR_POSITION=$((CURSOR_POSITION+1))
      fi
    elif [[ $key == "" ]]; then
      clear
      case $CURSOR_POSITION in
        0) echo "üè†  Executando teste local..."; AMBIENTE=local; break ;;
        1) echo "üê≥  Executando teste com docker..."; AMBIENTE=docker; break ;;
        2) echo "‚öì  Executando teste com kubernetes..."; AMBIENTE=k8s; break ;;
        3) echo "ü§ñ  Desinstalar DDroid..."; uninstall; exit;;
        4) echo "ü§ñüëã  At√© logo!"; exit ;;
      esac
    fi
  done
}

localOptions(){
  CURSOR_POSITION=0
  options=("üöÄ  Executar projeto local" "üóëÔ∏è   Limpar projeto local" "üîô  Voltar")
  print_menu() {
    for i in "${!options[@]}"; do
      if [[ "$i" -eq $CURSOR_POSITION ]]; then
        echo -e "${CURSOR} ${options[$i]}"
      else
        echo -e "  ${options[$i]}"
      fi
    done
  }
  while true; do
    clear
    echo -e "\e[1mü§ñ  Op√ßoes para ambiente üè†  Local:\e[0m"
    print_menu
    read -rsn3 key
    if [[ $key == $'\x1b[A' ]]; then
      if [[ "$CURSOR_POSITION" -gt 0 ]]; then
        CURSOR_POSITION=$((CURSOR_POSITION-1))
      fi
    elif [[ $key == $'\x1b[B' ]]; then
      if [[ "$CURSOR_POSITION" -lt $((${#options[@]}-1)) ]]; then
        CURSOR_POSITION=$((CURSOR_POSITION+1))
      fi
    elif [[ $key == "" ]]; then
      clear
      case $CURSOR_POSITION in
        0) LOCAL_OPTIONS=start; break ;;
        1) LOCAL_OPTIONS=clean; break ;;
        2) voltar; break ;;
      esac
    fi
  done
}

KbsOptions(){
  CURSOR_POSITION=0
  options=("üöÄ  Iniciar com Minikube" "‚öì  Deploy k8s" "üóëÔ∏è   Deletar deploys" "üß®  Destruir projeto" "üîô  Voltar")
  print_menu() {
    for i in "${!options[@]}"; do
      if [[ "$i" -eq $CURSOR_POSITION ]]; then
        echo -e "${CURSOR} ${options[$i]}"
      else
        echo -e "  ${options[$i]}"
      fi
    done
  }
  while true; do
    clear
    echo -e "\e[1mü§ñ  Op√ßoes com K8s‚öì:\e[0m"
    print_menu
    read -rsn3 key
    if [[ $key == $'\x1b[A' ]]; then
      if [[ "$CURSOR_POSITION" -gt 0 ]]; then
        CURSOR_POSITION=$((CURSOR_POSITION-1))
      fi
    elif [[ $key == $'\x1b[B' ]]; then
      if [[ "$CURSOR_POSITION" -lt $((${#options[@]}-1)) ]]; then
        CURSOR_POSITION=$((CURSOR_POSITION+1))
      fi
    elif [[ $key == "" ]]; then
      clear
      case $CURSOR_POSITION in
        0) KBS_OPTIONS=init; break ;;
        1) KBS_OPTIONS=start; break ;;
        2) KBS_OPTIONS=stop; break ;;
        3) KBS_OPTIONS=destroi; break ;;
        4) voltar; break ;;
      esac
    fi
  done
}

dockerOptions(){
  CURSOR_POSITION=0
  options=("üöÄ  Teste dev" "üöÄ  Teste producao" "üóëÔ∏è   Deletar containers do projeto" "üß®  Destruir tudo" "üîô  Voltar")

  print_menu() {
    for i in "${!options[@]}"; do
      if [[ "$i" -eq $CURSOR_POSITION ]]; then
        echo -e "${CURSOR} ${options[$i]}"
      else
        echo -e "  ${options[$i]}"
      fi
    done
  }
  while true; do
    clear
    echo -e "\e[1mü§ñ  Op√ßoes com Dockerüê≥:\e[0m"
    print_menu
    read -rsn3 key
    if [[ $key == $'\x1b[A' ]]; then
      if [[ "$CURSOR_POSITION" -gt 0 ]]; then
        CURSOR_POSITION=$((CURSOR_POSITION-1))
      fi
    elif [[ $key == $'\x1b[B' ]]; then
      if [[ "$CURSOR_POSITION" -lt $((${#options[@]}-1)) ]]; then
        CURSOR_POSITION=$((CURSOR_POSITION+1))
      fi
    elif [[ $key == "" ]]; then
      clear
      case $CURSOR_POSITION in
        0) DOCKER_OPTIONS=dev; break ;;
        1) DOCKER_OPTIONS=prod; break ;;
        2) DOCKER_OPTIONS=down; break ;;
        3) DOCKER_OPTIONS=prune; break ;;
        4) voltar; break ;;
      esac
    fi
  done
}

verificarInstalacao() {
  if [ ! -d "node_modules" ] || [ ! -f "package-lock.json" ]; then
    echo "ü§ñ  npm install"
    npm install
  fi
  echo "ü§ñ  dependencias do projeto instaladas"
}

verificarDesistalacao() {
  if [ -d "node_modules" ]; then
    echo -n "ü§ñ‚ùì Excluir a node_modules? [s/N]:"
    read -r response
    if [[ "$response" =~ ^([sS][iI]|[sS])$ ]]; then
      echo "ü§ñ  sudo rm -rf ./node_modules"
      sudo rm -rf ./node_modules
    fi
  fi
}

verificaBanco(){
  if docker ps --format '{{.Names}}' | grep -q "${DB_CONTAINER_NAME}"; then
    echo "ü§ñ  DB ${DB_CONTAINER_NAME} j√° est√° ativo."
  else
    echo "ü§ñ  DB ${DB_CONTAINER_NAME} n√£o est√° ativo. Iniciando..."
    echo "ü§ñ  docker compose up -d ${DB_CONTAINER_NAME}"
    docker compose up -d ${DB_CONTAINER_NAME}
  fi
}

verificaMigration(){
  echo
  echo -n "ü§ñ‚ùì Atualizar as migra√ß√µes? [s/N]:"
  read -r response
  if [[ "$response" =~ ^([sS][iI]|[sS])$ ]]; then
      echo "ü§ñ  npm run migration:run"
      npm run migration:run
  fi
}

verificarBuild(){
  IMAGE_NAME=$(grep "image: docker.io/${DOCKER_HUB_USER}/${DOCKER_HUB_IMAGE}" ./docker-compose-prod.yaml | awk '{print $2}')
  echo "veririfcar imagem ${IMAGE_NAME}"
  IMAGE_REPO=$(echo $IMAGE_NAME | awk -F: '{print $1}')
  IMAGE_TAG=$(echo $IMAGE_NAME | awk -F: '{print $2}')
  if [ -z "$IMAGE_TAG" ]; then
      IMAGE_TAG="latest"
  fi
  IMAGE_REPO=$(echo $IMAGE_REPO | sed 's/docker.io\///g')
  EXISTS=$(curl -so /dev/null -w "%{http_code}" https://hub.docker.com/v2/repositories/$IMAGE_REPO/tags/$IMAGE_TAG)

  if [ "$EXISTS" == "200" ]; then
      echo "ü§ñ Imagem existente no Docker Hub!"
  else
      echo "ü§ñ A imagem n√£o existe no Docker Hub. Construindo..."
      echo "ü§ñ docker build -t ${IMAGE_NAME} -f Dockerfile.prod ."
      docker build -t ${IMAGE_NAME} -f Dockerfile.prod .
      echo "ü§ñ docker push ${IMAGE_NAME}"
      docker push ${IMAGE_NAME}
      # criar a imagem latest
      if [ "$IMAGE_TAG" != "latest" ]; then
        docker tag ${IMAGE_REPO}:${IMAGE_TAG} ${IMAGE_REPO}:latest
        docker push ${IMAGE_REPO}:latest
      fi
  fi
}

localDev(){
  verificarInstalacao
  verificaBanco
  verificaMigration
  echo "ü§ñ  npm run start:dev"
  sleep 3
  npm run start:dev
}

localClean(){
  echo
  echo -n "ü§ñ‚ùì Limpar o banco de dados local? Todos os dados ser√£o perdidos! [s/N]:"
  read -r response
  if [[ "$response" =~ ^([sS][iI]|[sS])$ ]]; then
      echo "ü§ñ  docker compose down $DB_CONTAINER_NAME"
      docker compose down $DB_CONTAINER_NAME
      echo "üóëÔ∏è   sudo rm -rf $DB_VOLUME"
      sudo rm -rf $DB_VOLUME
  fi
  echo

  verificarDesistalacao
  echo "üóëÔ∏è   sudo rm -rf package-lock.json .npm-cache .wwebjs_auth .wwebjs_cache dist tmp"
  sudo rm -rf package-lock.json .npm-cache .wwebjs_auth .wwebjs_cache dist tmp
  exit
}

dockerProd(){
  echo -e "\e[1müê≥ Docker - Teste simulando imagem de produ√ß√£o\e[0m"
  verificarBuild
  echo "ü§ñ  docker compose -f docker-compose-prod.yaml up -d"
  docker compose -f docker-compose-prod.yaml up -d
  verificaMigration
  echo "ü§ñ  docker logs $BACK_CONTAINER_NAME -f"
  docker logs $BACK_CONTAINER_NAME -f 
  exit
}

dockerDev(){
  echo -e "\e[1müê≥ Docker - Teste em ambiente de desenvolvimento\e[0m"
  echo "ü§ñ  docker compose up -d"
  docker compose up -d
  verificarInstalacao
  verificaMigration
  echo "ü§ñ  docker exec -it $BACK_CONTAINER_NAME /bin/sh -c 'npm run start:dev'"
  echo "ü§ñ  docker logs $BACK_CONTAINER_NAME -f"
  docker exec -it $BACK_CONTAINER_NAME /bin/sh -c "npm run start:dev"
  docker logs $BACK_CONTAINER_NAME -f
  exit
}

dockerDown(){
  echo "ü§ñ  docker compose down"
  docker compose down
  exit
}

dockerPrune(){
  echo
  echo -n "‚ö†Ô∏èü§ñ‚ùì  Deseja mesmo continuar? Todos os dados do Docker üê≥ ser√£o perdido! [s/N]:"
  read -r response
  if [[ "$response" =~ ^([sS][iI]|[sS])$ ]]; then
      echo "ü§ñ  docker system prune -a"
      exit
  fi
  echo "ü§ñ  Opera√ß√£o cancelada."
}

k8sApply(){
  echo "ü§ñ  Iniciando deploy"
  source ddroid.env

  # DATABASE
  echo
  echo "üì¶  Iniciando configura√ß√µes do ${K8S_DB_POD_NAME}..."
  echo "ü§ñ  kubectl apply -f ${K8S_DB_FOLDER}"
  kubectl apply -f ${K8S_DB_FOLDER}
  while [[ $(kubectl get pods -l app=${K8S_DB_POD_NAME} -o 'jsonpath={..status.conditions[?(@.type=="Ready")].status}') != "True" ]]; do
    echo
    echo "ü§ñ  kubectl get pods -l app=${K8S_DB_POD_NAME}"
    kubectl get pods -l app=${K8S_DB_POD_NAME}
    sleep 5
  done
  echo
  echo "ü§ñ  kubectl get pods -l app=${K8S_DB_POD_NAME} -o jsonpath='{.items[0].metadata.name}'"
  DB_POD=$(kubectl get pods -l app=${K8S_DB_POD_NAME} -o jsonpath='{.items[0].metadata.name}')
  echo "ü§ñ  ${DB_POD}"
  echo
  echo "ü§ñ  kubectl port-forward ${DB_POD} ${K8S_DB_PORTS[0]}:${K8S_DB_PORTS[1]} & echo $! > tmp/db-port-forward.pid"
  kubectl port-forward ${DB_POD} ${K8S_DB_PORTS[0]}:${K8S_DB_PORTS[1]} &
  echo $! > tmp/db-port-forward.pid
  echo
  echo "ü§ñ  üîó Port-forward em segundo plano ${K8S_DB_PORTS[0]}:${K8S_DB_PORTS[1]}"
  DB_ENDPOINT=$(kubectl get service ${K8S_DB_SERVICE_NAME} -o=jsonpath='{.spec.clusterIP}')
  echo
  echo "ü§ñ  kubectl create configmap ${K8S_API_POD_NAME}-config --from-literal=instance_host=${DB_ENDPOINT} --dry-run=client -o yaml | kubectl apply -f -"
  kubectl create configmap ${K8S_API_POD_NAME}-config --from-literal=instance_host=${DB_ENDPOINT} --dry-run=client -o yaml | kubectl apply -f -

  # API
  echo
  echo "üì¶  Iniciando configura√ß√µes da API..."
  echo "ü§ñ  kubectl apply -f ${K8S_API_FOLDER}"
  kubectl apply -f ${K8S_API_FOLDER}
  while [[ $(kubectl get pods -l app=${K8S_API_POD_NAME} -o 'jsonpath={..status.conditions[?(@.type=="Ready")].status}') != "True" ]]; do
    echo
    echo "ü§ñ  kubectl get pods -l app=${K8S_API_POD_NAME}"
    kubectl get pods -l app=${K8S_API_POD_NAME}
    sleep 5
  done
  APP_POD=$(kubectl get pods -l app=${K8S_API_POD_NAME} -o jsonpath='{.items[0].metadata.name}')
  echo
  echo -n "ü§ñ‚ùì Atualizar as migra√ß√µes? [s/N]:"
  read -r response
  if [[ "$response" =~ ^([sS][iI]|[sS])$ ]]; then
    echo
    echo "ü§ñ  Executando migra√ß√µes..."
    echo "ü§ñ  kubectl exec ${APP_POD} -- npm run migration:run"
    kubectl exec ${APP_POD} -- npm run migration:run
  fi
  echo
  echo "ü§ñ  kubectl port-forward ${APP_POD} ${K8S_APP_PORTS[0]}:${K8S_APP_PORTS[1]} & echo $! > tmp/app-port-forward.pid"
  kubectl port-forward ${APP_POD} ${K8S_APP_PORTS[0]}:${K8S_APP_PORTS[1]} &
  echo $! > tmp/app-port-forward.pid
  echo
  echo "ü§ñ  üîó Port-forward do ${BACK_CONTAINER_NAME} em segundo plano ${K8S_APP_PORTS[0]}:${K8S_APP_PORTS[1]}"
  echo
  echo "ü§ñ  ‚úÖ Deploy conclu√≠do!"
  echo
  echo "ü§ñ  kubectl logs -f $APP_POD"
  kubectl logs -f $APP_POD
}

k8sDelete(){
  echo
  echo "ü§ñ  üöÄ  Encerrando projeto"
  if [ -f tmp/db-port-forward.pid ]; then
      PID=$(cat tmp/db-port-forward.pid)
      kill $PID
      echo "ü§ñ  rm tmp/db-port-forward.pid"
      rm tmp/db-port-forward.pid
      echo "ü§ñ  üõë  processo port-forward do ${DB_CONTAINER_NAME} com PID $PID foi interrompido."
  else
      echo "ü§ñ  ‚ö†Ô∏è  arquivo db-port-forward.pid n√£o encontrado. Parece que o port-forward do ${DB_CONTAINER_NAME} n√£o foi iniciado por este script."
  fi
  if [ -f tmp/app-port-forward.pid ]; then
      PID=$(cat tmp/app-port-forward.pid)
      kill $PID
      echo "ü§ñ  rm tmp/app-port-forward.pid"
      rm tmp/app-port-forward.pid
      echo "ü§ñ  üõë  processo port-forward do ${BACK_CONTAINER_NAME} com PID $PID foi interrompido."
  else
      echo "ü§ñ  ‚ö†Ô∏è  arquivo app-port-forward.pid n√£o encontrado. Parece que o port-forward do ${BACK_CONTAINER_NAME} n√£o foi iniciado por este script."
  fi
  echo
  echo "ü§ñ  üóëÔ∏è  kubectl delete -f ${K8S_DB_FOLDER}"
  kubectl delete -f ${K8S_DB_FOLDER}
  echo
  echo "ü§ñ  üóëÔ∏è  kubectl delete -f ${K8S_API_FOLDER}"
  kubectl delete -f ${K8S_API_FOLDER}
  echo
  echo "ü§ñ  üóëÔ∏è  kubectl delete configmap ${K8S_API_POD_NAME}-config"
  kubectl delete configmap ${K8S_API_POD_NAME}-config
  echo
  echo "ü§ñ  ‚úÖ projeto encerrado"
}

k8sDestroy(){
  echo -n "ü§ñ‚ö†Ô∏è  Deseja mesmo continuar? Todo o cluster ser√° perdido! [s/N]:"
  read -r response
  if [[ "$response" =~ ^([sS][iI]|[sS])$ ]]; then
      k8sDelete
      echo "ü§ñ  minikube delete --all"
      sleep 3
      minikube delete --all
      exit
  fi
  echo "ü§ñ  Opera√ß√£o cancelada."
}

uninstall(){
  echo -n "ü§ñ  Remover o DDroid do seu projeto? [s/N]:"
  read -r response
  if [[ "$response" =~ ^([sS][iI]|[sS])$ ]]; then
    echo
    echo "ü§ñüî´ ..."
    echo
    sleep 2

    # Remove o script ddroid de ~/bin
    if [ -f ~/bin/ddroid ]; then
        rm ~/bin/ddroid
        # echo "Script ddroid removido com sucesso de ~/bin!"
    else
        echo "Script ddroid n√£o encontrado em ~/bin!"
    fi

    echo
    echo "‚ö∞Ô∏è  DDroid foi desinstalado com sucesso!"
    exec $SHELL
  else
    echo "Desinstala√ß√£o cancelada."
    exit 0
  fi
}

load_or_create_env

while true; do

  unsetVars

  if [ "$AMBIENTE" = "none" ]; then
    defineAmbiente
  fi

  if [ "$AMBIENTE" = "local" ]; then
    localOptions
    case $LOCAL_OPTIONS in
      start)
        localDev
        ;;
      clean)
        localClean
        ;;
    esac
  fi

  if [ "$AMBIENTE" = "docker" ]; then
    dockerOptions
    case $DOCKER_OPTIONS in
      dev)
        dockerDev
        ;;
      prod)
        dockerProd
        ;;
      down)
        dockerDown
        ;;
      prune)
        dockerPrune
        ;;
    esac
  fi

  if [ "$AMBIENTE" = "k8s" ]; then
    KbsOptions
    case $KBS_OPTIONS in
      init)
        echo "ü§ñ  minikube start"
        minikube start
        k8sApply;
        exit;;
      start)
        k8sApply;
        exit;;
      stop)
        k8sDelete;
        exit;;
      destroi)
        k8sDestroy;
        exit;;
    esac
  fi
done